#!/bin/sh
# Shell Script for running the GDiff Tool

#echo "Parsing and Analyzing folder: "

if [[ $# -gt 3 ]]; then
echo "Usage: bash gdiff.sh <full path to Software v1> [<full path to software v2>  <path to bug xml file>]"
echo "More than two argument. Exit..."
exit 0
fi

PATH_V1="$1"
echo "Path to version 1: ${PATH_V1}"

PATH_V2="$2"
echo "Path to version 2: ${PATH_V2}"

# Create a folder to save tmp files generated by gdiff, remove old files, if present.
rm -rf /tmp/gdiff/runs/*
mkdir -p /tmp/gdiff/runs

if [[ $2 == *"NULL"* ]]; then
python configFileModifier.py remove 
fi

if [[ $# -eq 2 ]]; then
echo "Run gdiff as version diff and generate call graph"

##########################################################################################
# 			     Run gdiff as Version Diff
##########################################################################################

echo "************** Generate ctags ************"
ctags -RV -x --c-types=f ${PATH_V1}/* > /tmp/gdiff/runs/gdiff_tags_v1
echo "ctags generated as file /tmp/gdiff/runs/gdiff_tags_v1"


# Determine the count of main() functions in specified software application
# If more than one main(), modify them as main_<filename>().
# So cflow consider all main() as different and generate different call paths.
# If there is only one main(), script exits...
echo "************** Processing ctags... ***********"
python parse_ctags.py /tmp/gdiff/runs/gdiff_tags_v1


echo "************ finding all *.c files in project ***********"
C_FILES=$(find ${PATH_V1}/* -type f -name "*.c") # > /tmp/gdiff/runs/find_output_v1
#echo "all files are listed in /tmp/gdiff/runs/find_output file\n"

SAVE_CWD=$PWD
echo "*************** Run cflow on all *.c files ***********"
echo "Running cflow..."

# Change the current pwd to specified software root folder and run cflow
cd ${PATH_V1}
echo $C_FILES
cflow $C_FILES -o /tmp/gdiff/runs/all_cflow
#cflow inode.c namei.c locks.c read_write.c -o /tmp/gdiff/runs/all_cflow
#cflow server/*.c server/mpm/event/*.c server/mpm/worker/*.c server/mpm/netware/*.c server/mpm/prefork/*.c server/mpm/winnt/*.c server/mpm/mpmt_os2/*.c  modules/aaa/*.c modules/arch/*.c modules/cache/*.c support/*.c os/beos/beosd.c os/bs2000/*.c os/netware/*.c os/os2/*.c os/tpf/*.c os/unix/*.c os/win32/*.c  -o /tmp/gdiff/runs/all_cflow
#cflow inode.c  -o /tmp/gdiff/runs/all_cflow

# Added an extra line for D3 requirement for call graph UI.
#echo " " >> /tmp/gdiff/runs/all_cflow
grep -q -F " " /tmp/gdiff/runs/all_cflow || echo " " >> /tmp/gdiff/runs/all_cflow

# Back to old path
cd $SAVE_CWD
echo "cflow output at  /tmp/gdiff/runs/all_cflow file\n"

# Remove all std library functions from the cflow output and write result in gdiff_cflow_v1.
python remove_stdlibs_functions.py /tmp/gdiff/runs/all_cflow /tmp/gdiff/runs/gdiff_cflow_v1

echo "Removed standard library functions from all_flow and result stored in gdiff_cflow\n"

# Restore all main functions in software, if modified in previous step
echo "**************Restoring backups...*********"
python restore_files_frm_bakup.py /tmp/gdiff/runs/gdiff_tags_v1 



printf "\n\n"
if [[ $2 != *"NULL"* ]]; then
echo "Version 2 present... Run tool..."


echo " *********** Run for ver2 ********** "
echo " *********** ************ ********** "
echo " *********** ************ ********** "
printf "\n\n"

# Edit config_file.cfg for D3
python configFileModifier.py add

echo "************** Generate ctags ************"
ctags -RV -x --c-types=f ${PATH_V2}/* > /tmp/gdiff/runs/gdiff_tags_v2
echo "ctags generated as file /tmp/gdiff/runs/gdiff_tags_v2"


echo "************** Processing ctags...***********"
python parse_ctags.py /tmp/gdiff/runs/gdiff_tags_v2


echo "************ finding all *.c files in project ***********"
C_FILES_V2=$(find ${PATH_V2}/* -type f -name "*.c") # > /tmp/gdiff/runs/find_output_v2
#echo "all files are listed in /tmp/gdiff/runs/find_output_v2 file\n"

SAVE_CWD=$PWD
echo "*************** Run cflow on all *.c files ***********"
echo "Running cflow..."
cd ${PATH_V2}
echo $C_FILES_V2
cflow $C_FILES_V2 -o /tmp/gdiff/runs/all_cflow2

#cflow inode.c namei.c locks.c read_write.c -o /tmp/gdiff/runs/all_cflow2
#cflow server/*.c server/mpm/event/*.c server/mpm/worker/*.c server/mpm/netware/*.c server/mpm/prefork/*.c server/mpm/winnt/*.c server/mpm/mpmt_os2/*.c  modules/aaa/*.c modules/arch/*.c modules/cache/*.c support/*.c os/beos/beosd.c os/bs2000/*.c os/netware/*.c os/os2/*.c os/tpf/*.c os/unix/*.c os/win32/*.c  -o /tmp/gdiff/runs/all_cflow2
#cflow inode.c  -o /tmp/gdiff/runs/all_cflow2

#echo " " >> /tmp/gdiff/runs/all_cflow2
grep -q -F " " /tmp/gdiff/runs/all_cflow2 || echo " " >> /tmp/gdiff/runs/all_cflow2

# Back tp old path
cd $SAVE_CWD

echo "cflow output at  /tmp/gdiff/runs/all_cflow2 file"
python remove_stdlibs_functions.py /tmp/gdiff/runs/all_cflow2 /tmp/gdiff/runs/gdiff_cflow_v2

echo "Removed standard library functions from all_flow and result stored in gdiff_cflow2\n"

echo "**************Restoring backups...*********"
python restore_files_frm_bakup.py /tmp/gdiff/runs/gdiff_tags_v2

# End for NULL Check for software version 2.
fi

# Generate dummy result.txt in /tmp/gdiff/runs , as there are no bugs.
touch /tmp/gdiff/runs/result.txt

# End for $# = 2
fi

##########################################################################################
# 			     Gdiff as Bug Analyzer
##########################################################################################

if [[ $# -eq 3 ]]; then
BUG_XML_FILE="$3"
echo "Path to XML Bug file: ${BUG_XML_FILE}"

echo "************** Generate ctags ************"
ctags -RV -x --c-types=f ${PATH_V1}/* > /tmp/gdiff/runs/gdiff_tags_v1

### Download all the bugs and get call traces
python BugParser/mybugzilla.py -x ${BUG_XML_FILE}

echo "Paring results in BugParser/result.txt"

## Get all .c files in which we need to run cflow
GC_FILES_V1=$(python BugParser/parse_abrt.py BugParser/result.txt /tmp/gdiff/runs/gdiff_tags_v1)

SAVE_CWD=$PWD
echo "*************** Run cflow on all *.c files ***********"
echo "Running cflow..."

# Change the current pwd to specified software root folder and run cflow
cd ${PATH_V1}
echo $GC_FILES_V1
cflow $GC_FILES_V1 -o /tmp/gdiff/runs/all_cflow

# Added an extra line for D3 requirement for call graph UI.
#echo " " >> /tmp/gdiff/runs/all_cflow
grep -q -F " " /tmp/gdiff/runs/all_cflow || echo " " >> /tmp/gdiff/runs/all_cflow

# Back to old path
cd $SAVE_CWD
echo "cflow output at  /tmp/gdiff/runs/all_cflow file\n"

# Remove all std library functions from the cflow output and write result in gdiff_cflow_v1.
python remove_stdlibs_functions.py /tmp/gdiff/runs/all_cflow /tmp/gdiff/runs/gdiff_cflow_v1

echo "Removed standard library functions from all_flow and result stored in gdiff_cflow\n"


printf "\n\n"
if [[ $2 != *"NULL"* ]]; then
echo "Version 2 present... Run tool..."


echo " *********** Run for ver2 ********** "
echo " *********** ************ ********** "
echo " *********** ************ ********** "
printf "\n\n"


# Edit config_file.cfg for D3
python configFileModifier.py add

echo "************** Generate ctags ************"
ctags -RV -x --c-types=f ${PATH_V2}/* > /tmp/gdiff/runs/gdiff_tags_v2

## Get all .c files in which we need to run cflow
GC_FILES_V2=$(python BugParser/parse_abrt.py BugParser/result.txt /tmp/gdiff/runs/gdiff_tags_v2)

SAVE_CWD=$PWD
echo "*************** Run cflow on all *.c files ***********"
echo "Running cflow..."

# Change the current pwd to specified software root folder and run cflow
cd ${PATH_V2}
echo $GC_FILES_V2
cflow $GC_FILES_V2 -o /tmp/gdiff/runs/all_cflow2

# Added an extra line for D3 requirement for call graph UI.
#echo " " >> /tmp/gdiff/runs/all_cflow2
grep -q -F " " /tmp/gdiff/runs/all_cflow2 || echo " " >> /tmp/gdiff/runs/all_cflow2

# Back to old path
cd $SAVE_CWD
echo "cflow output at  /tmp/gdiff/runs/all_cflow2 file\n"

# Remove all std library functions from the cflow output and write result in gdiff_cflow_v1.
python remove_stdlibs_functions.py /tmp/gdiff/runs/all_cflow2 /tmp/gdiff/runs/gdiff_cflow_v2

echo "Removed standard library functions from all_flow and result stored in gdiff_cflow\n"

# End for NULL Check for software version 2.
fi

# Copy Result.txt to /tmp/gdiff/runs folder for graph UI
cp BugParser/result.txt /tmp/gdiff/runs/result.txt

# End for $# = 2
fi

#exit 0



##########################################################################################
# 			     Common Part: Generate Call Graph
##########################################################################################
# Generate the Static Call Graph based on cflow output
python runserver.py

